"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import { spring, tween, decay, keyframes, physics, value, chain, easing, delay as delayAction } from 'popmotion';
import poseFactory from 'pose-core';
import defaultTransitions, { just } from '../inc/default-transitions';
import { number, degrees, percent, px } from 'style-value-types';
import { invariant } from 'hey-listen';
var valueTypeTests = [number, degrees, percent, px];
var testValueType = function (v) { return function (type) { return type.test(v); }; };
var createPassiveValue = function (init, parent, transform) {
    var raw = value(init).pipe(transform);
    parent.raw.subscribe(raw);
    return { raw: raw };
};
var createValue = function (init) {
    var type = valueTypeTests.find(testValueType(init));
    var raw = value(type === number ? type.parse(init) : init);
    return { raw: raw, type: type };
};
var addActionDelay = function (delay, transition) {
    if (delay === void 0) { delay = 0; }
    return chain(delayAction(delay), transition);
};
var animationLookup = new Map([
    ['tween', tween],
    ['spring', spring],
    ['decay', decay],
    ['keyframes', keyframes],
    ['physics', physics]
]);
var easeIn = easing.easeIn, easeOut = easing.easeOut, easeInOut = easing.easeInOut, circIn = easing.circIn, circOut = easing.circOut, circInOut = easing.circInOut, backIn = easing.backIn, backOut = easing.backOut, backInOut = easing.backInOut, anticipate = easing.anticipate;
var easingLookup = new Map([
    ['easeIn', easeIn],
    ['easeOut', easeOut],
    ['easeInOut', easeInOut],
    ['circIn', circIn],
    ['circOut', circOut],
    ['circInOut', circInOut],
    ['backIn', backIn],
    ['backOut', backOut],
    ['backInOut', backInOut],
    ['anticipate', anticipate]
]);
var getAction = function (v, _a, _b) {
    var from = _b.from, to = _b.to, velocity = _b.velocity;
    var _c = _a.type, type = _c === void 0 ? 'tween' : _c, ease = _a.ease, def = __rest(_a, ["type", "ease"]);
    invariant(animationLookup.has(type), "Invalid transition type '" + type + "'. Valid transition types are: tween, spring, decay, physics and keyframes.");
    if (type === 'tween') {
        var typeOfEase = typeof ease;
        if (typeOfEase !== 'function') {
            if (typeOfEase === 'string') {
                invariant(easingLookup.has(ease), "Invalid easing type '" + ease + "'. popmotion.io/pose/api/transition");
                ease = easingLookup.get(ease);
            }
            else if (Array.isArray(ease)) {
                invariant(ease.length === 4, "Cubic bezier arrays must contain four numerical values.");
                var x1 = ease[0], y1 = ease[1], x2 = ease[2], y2 = ease[3];
                ease = easing.cubicBezier(x1, y1, x2, y2);
            }
        }
    }
    return animationLookup.get(type)(__assign({ from: from,
        to: to,
        velocity: velocity,
        ease: ease }, def));
};
var isAction = function (action) {
    return typeof action.start !== 'undefined';
};
var pose = function (_a) {
    var transformPose = _a.transformPose, addListenerToValue = _a.addListenerToValue, extendAPI = _a.extendAPI, readValueFromSource = _a.readValueFromSource;
    return poseFactory({
        bindOnChange: function (values, onChange) { return function (key) {
            if (!values.has(key))
                return;
            var raw = values.get(key).raw;
            raw.subscribe(onChange[key]);
        }; },
        readValue: function (_a) {
            var raw = _a.raw;
            return raw.get();
        },
        createValue: function (init, key, _a, _b) {
            var elementStyler = _a.elementStyler;
            var _c = _b === void 0 ? {} : _b, passiveParent = _c.passiveParent, passiveProps = _c.passiveProps;
            var val = passiveParent
                ? createPassiveValue(init, passiveParent, passiveProps)
                : createValue(init);
            if (addListenerToValue) {
                val.raw.subscribe(addListenerToValue(key, elementStyler));
            }
            return val;
        },
        convertValue: function (raw, key, _a) {
            var elementStyler = _a.elementStyler;
            if (addListenerToValue) {
                raw.subscribe(addListenerToValue(key, elementStyler));
            }
            return {
                raw: raw,
                type: valueTypeTests.find(testValueType(raw.get()))
            };
        },
        getTransitionProps: function (_a, to) {
            var raw = _a.raw, type = _a.type;
            return ({
                from: type ? type.parse(raw.get()) : raw.get(),
                velocity: raw.getVelocity(),
                to: type ? type.parse(to) : to,
                type: type
            });
        },
        resolveTarget: function (_a, to) {
            var type = _a.type;
            return (type ? type.parse(to) : to);
        },
        selectValueToRead: function (_a) {
            var raw = _a.raw;
            return raw;
        },
        startAction: function (_a, action, complete) {
            var raw = _a.raw, type = _a.type;
            var reaction = {
                update: function (v) { return raw.update(v); },
                complete: complete
            };
            return type
                ? action.pipe(type.transform).start(reaction)
                : action.start(reaction);
        },
        stopAction: function (action) { return action.stop(); },
        getInstantTransition: function (_, _a) {
            var to = _a.to;
            return just(to);
        },
        convertTransitionDefinition: function (val, def, props) {
            if (isAction(def))
                return def;
            var delay = def.delay, min = def.min, max = def.max, round = def.round, remainingDef = __rest(def, ["delay", "min", "max", "round"]);
            var action = getAction(val, remainingDef, props);
            var outputPipe = [];
            if (delay)
                addActionDelay(delay, action);
            if (min !== undefined)
                outputPipe.push(function (v) { return Math.max(v, min); });
            if (max !== undefined)
                outputPipe.push(function (v) { return Math.min(v, max); });
            if (round)
                outputPipe.push(Math.round);
            return outputPipe.length ? action.pipe.apply(action, outputPipe) : action;
        },
        addActionDelay: addActionDelay,
        defaultTransitions: defaultTransitions,
        transformPose: transformPose,
        readValueFromSource: readValueFromSource,
        extendAPI: extendAPI
    });
};
export default pose;
//# sourceMappingURL=pose.js.map