"use strict";
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};
import poseFactory from '../factories/pose';
import createDimensions from './dimensions';
import appendEventListeners from './events';
import { flipPose, isFlipPose } from './flip';
import { styler } from 'popmotion';
import { Action } from 'popmotion/action';
import { ValueReaction } from 'popmotion/reactions/value';
import { ColdSubscription } from 'popmotion/action/types';
export { Action, ValueReaction, ColdSubscription };
var dragPoses = function (draggable) {
    var dragging = {
        preTransition: function (_a) {
            var dimensions = _a.dimensions;
            return dimensions.measure();
        }
    };
    var dragEnd = {};
    if (draggable === true || draggable === 'x')
        dragging.x = dragEnd.x = 0;
    if (draggable === true || draggable === 'y')
        dragging.y = dragEnd.y = 0;
    return { dragging: dragging, dragEnd: dragEnd };
};
var createPoseConfig = function (element, _a) {
    var onDragStart = _a.onDragStart, onDragEnd = _a.onDragEnd, draggable = _a.draggable, dragBounds = _a.dragBounds, config = __rest(_a, ["onDragStart", "onDragEnd", "draggable", "dragBounds"]);
    var poseConfig = __assign({ flip: {} }, config, { props: __assign({}, config.props, { draggable: draggable,
            onDragStart: onDragStart,
            onDragEnd: onDragEnd,
            dragBounds: dragBounds,
            element: element, elementStyler: styler(element, { preparseOutput: false }), dimensions: createDimensions(element) }) });
    if (draggable) {
        var _b = dragPoses(draggable), dragging = _b.dragging, dragEnd = _b.dragEnd;
        poseConfig.dragging = __assign({}, poseConfig.dragging, dragging);
        poseConfig.dragEnd = __assign({}, poseConfig.dragEnd, dragEnd);
    }
    return poseConfig;
};
var domPose = poseFactory({
    transformPose: function (_a, name, state) {
        var flip = _a.flip, pose = __rest(_a, ["flip"]);
        return isFlipPose(flip, name, state) ? flipPose(state, pose) : pose;
    },
    addListenerToValue: function (key, elementStyler) { return function (v) { return elementStyler.set(key, v); }; },
    readValueFromSource: function (key, _a) {
        var elementStyler = _a.elementStyler;
        var value = elementStyler.get(key);
        return isNaN(value) ? value : parseFloat(value);
    },
    extendAPI: function (api, _a, config) {
        var props = _a.props, activeActions = _a.activeActions;
        var measure = props.dimensions.measure;
        var poserApi = __assign({}, api, { addChild: function (element, childConfig) {
                return api._addChild(createPoseConfig(element, childConfig), domPose);
            }, measure: measure, flip: function (op) {
                if (op) {
                    measure();
                    op();
                }
                return api.set('flip');
            } });
        appendEventListeners(props.element, activeActions, api.set, config);
        return poserApi;
    }
});
export default function (element, config) {
    return domPose(createPoseConfig(element, config));
};
//# sourceMappingURL=pose.js.map